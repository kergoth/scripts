#!/usr/bin/env bash
#
# library-sync: Synchronize my game library with a device
#
# Light wrapper around grabbing a config file and using it to generate libsync commands and run them.
#
# Usage: library-sync [options] [source] [destination_root]
#
# Options:
#     -c CONFIG_FILE  Use the specified configuration file. If the path is relative,
#                     assume it's relative to the 'source' directory. Default: source/.library-sync
#     -C              Conditional mode. Expect config file lines to be in the format "check_path\tsource_path destination_path",
#                     where check_path is a path to a file or directory that must exist for the sync to occur.
#                     If check_path is prefixed by a !, it must not exist.
#     -H              Hoist the contents of a single-directory compressed archive to the destination path, rather than creating a subdirectory
#     -i PATTERN      Include only source paths matching PATTERN
#     -x PATTERN      Exclude source paths matching PATTERN
#     -l              Hard link files in a local file copy, rather than copying with rsync, if DESTPATH is local
#     -k              Continue as much as possible after an error
#     -n              Dry run, don't actually do anything
#     -v              Increase verbosity, can be specified multiple times
#     -q              Decrease verbosity, can be specified multiple times
#     -h              Show this help message and exit.

set -euo pipefail

# Exit with error on bash <4.0
if [ "${BASH_VERSINFO:-0}" -lt 4 ]; then
    echo "Error: Bash version 4.0 or higher is required." >&2
    exit 1
fi

scriptdir=$(cd "$(dirname "$(readlink -f "$0")")" && pwd -P)
PATH="$scriptdir:$PATH"

tmpdir=$(mktemp -d)
# Clean up after ourselves
trap 'rm -rf "$tmpdir"' EXIT
# Allow clean handling of libsync's interruption, and ensure we leave no child processes behind
suppress_int=
trap 'if [ -z "$suppress_int" ]; then trap - INT; kill -INT -- -$$ &>/dev/null; kill -INT $$ &>/dev/null; fi; suppress_int=' INT
# Ensure we leave no child processes behind on termination
trap 'trap - TERM; kill -TERM -- -$$ &>/dev/null; kill -TERM $$ &>/dev/null;' TERM

show_help() {
    sed -n '/^# Usage:/,/^# *-h /p' "$0" | sed 's/^# *//'
}

process_arguments() {
    config_file=.library-sync
    conditional_mode=0
    hoist=0
    include=
    exclude=
    hard_link=0
    continue_on_error=
    dry_run=
    verbosity=0
    libsync_opts=()

    while getopts "c:CHi:x:lknvqh" opt; do
        case $opt in
        c) config_file=$OPTARG ;;
        C) conditional_mode=1 ;;
        H) hoist=1 ;;
        i) include=$OPTARG ;;
        x) exclude=$OPTARG ;;
        l) hard_link=1 ;;
        k) continue_on_error=1 ;;
        n) dry_run=1 ;;
        v) verbosity=$((verbosity + 1)) ;;
        q) verbosity=$((verbosity - 1)) ;;
        h)
            show_help
            exit 0
            ;;
        *)
            show_help
            exit 1
            ;;
        esac
    done
    shift $((OPTIND - 1))

    if [ "$verbosity" -gt 1 ]; then
        libsync_opts+=("-$(printf 'v%.0s' $(seq 2 $verbosity))")
    elif [ "$verbosity" -lt 0 ]; then
        libsync_opts+=("-$(printf 'q%.0s' $(seq 1 ${verbosity#-}))")
    fi
    if [ "$hoist" -eq 1 ]; then
        libsync_opts+=("-c")
    fi
    if [ "$hard_link" -eq 1 ]; then
        libsync_opts+=("-H")
    fi
}

# shellcheck disable=SC2120
filter() {
    if [ -n "$include" ]; then
        grep -E ${nocase:+-i} "$@" "$include" || :
    else
        cat
    fi |
        if [ -n "$exclude" ]; then
            grep -Ev ${nocase:+-i} "$@" "$exclude" || :
        else
            cat
        fi
}

check_filter() {
    # shellcheck disable=SC2119
    test -n "$(filter)"
}

msg() {
    fmt="$1"
    if [ $# -gt 1 ]; then
        shift
    fi
    # shellcheck disable=SC2059
    printf "$fmt\n" "$@" >&2
}

msg_color() {
    local color=$1
    shift
    local msg=$1
    shift
    # shellcheck disable=SC2059
    if [ -n "${NO_COLOR:-}" ] || { [ -z "${COLOR:-}" ] && ! [ -t 1 ]; }; then
        printf "${msg}\n" "$@" >&2
        return
    else
        printf "\033[${color}m${msg}\033[0m\n" "$@" >&2
    fi
}

msg_blue() {
    msg_color '34' "$@"
}

msg_green() {
    msg_color '32' "$@"
}

msg_red() {
    msg_color '31' "$@"
}

msg_yellow() {
    msg_color '33' "$@"
}

msg_verbose() {
    if [ "${verbosity:-0}" -gt 0 ]; then
        msg_yellow "$@"
    fi
}

msg_debug() {
    if [ "${verbosity:-0}" -gt 1 ]; then
        msg "$@"
    fi
}

msg_verydebug() {
    if [ "${verbosity:-0}" -gt 2 ]; then
        msg "$@"
    fi
}

die() {
    msg_red "$@"
    exit 1
}

should_die() {
    local ret=$?
    local msg=${1:-}

    case $ret in
    130)
        msg_red "${msg:+$msg, }Interrupted"
        kill -INT $$
        ;;
    0) ;;
    *)
        if [ -n "${continue_on_error:-}" ]; then
            msg_yellow "Error: ${msg:+$msg, }Continuing after error with exit code $ret"
            return $ret
        else
            die "Error: ${msg:+$msg, }Failed with exit code $ret"
        fi
        ;;
    esac
}

printcmd() {
    python3 -c 'import subprocess,sys; print(subprocess.list2cmdline(sys.argv[1:]))' "$@"
}

run() {
    local ret=0
    if [ "${dry_run:-0}" = "1" ] || [ "${verbosity:-0}" -gt 0 ]; then
        printf '❯ %s\n' "$(printcmd "$@")" >&2
    fi
    if [ "${dry_run:-0}" != "1" ]; then
        suppress_int=1
        (
            trap - INT EXIT TERM
            exec "$@"
        ) &
        wait $! || ret=$?
    fi
    return $ret
}

run_always() {
    local ret=0
    if [ "${verbosity:-0}" -gt 0 ]; then
        printf '❯ %s\n' "$(printcmd "$@")" >&2
    fi
    suppress_int=1
    (
        trap - INT EXIT TERM
        exec "$@"
    ) &
    wait $! || ret=$?
    return $ret
}

run_libsync() {
    local paths=()
    for arg; do
        if [ "$arg" = "--" ]; then
            shift
            break
        fi
        paths+=("$arg")
        shift
    done
    local src_paths=("${paths[@]:0:${#paths[@]}-1}")
    local sync_dest=${paths[-1]}

    local skip=1
    for i in "${!src_paths[@]}"; do
        src=${src_paths[$i]}
        if printf '%s\t%s\n' "$src" "$sync_dest" | check_filter; then
            skip=0
        fi
        case "$src" in
        /*) ;;
        *) src="$source/$src" ;;
        esac
        src_paths[i]="$src"
    done
    if [ "$skip" = "1" ]; then
        msg_verydebug "Skipping sync due to filters: ${src_paths[*]}\n"
        return 0
    fi
    case "$sync_dest" in
    /*)
        case "$destination_root" in
        *:*)
            dest_host=${destination_root%%:*}
            sync_dest="$dest_host:$sync_dest"
            ;;
        *) sync_dest="$destination_root/$sync_dest" ;;
        esac
        ;;
    *) sync_dest="$destination_root/$sync_dest" ;;
    esac

    if [ $# -gt 0 ]; then
        set -- -uswC ${dry_run:+-n} "${libsync_opts[@]}" "${src_paths[@]}" "$sync_dest" -- "$@"
    else
        set -- -uswC ${dry_run:+-n} "${libsync_opts[@]}" "${src_paths[@]}" "$sync_dest"
    fi

    run_always libsync "$@" </dev/null
}

run_remote() {
    local host="$1"
    shift
    local dashx=
    if [ "${verbosity:-0}" -gt 0 ]; then
        dashx=-x
    fi
    set -- bash $dashx -c "$(quote-args "$@")"
    if [ -t 0 ]; then
        cat /dev/null
    else
        cat
    fi |
        run ssh -q -o BatchMode=yes -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null "$host" "$(quote-args "$@")"
}

run_remote_quiet() {
    local host="$1"
    shift
    if [ -t 0 ]; then
        cat /dev/null
    else
        cat
    fi |
        ssh -q -o BatchMode=yes -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null "$host" "$(quote-args "$@")"
}

run_dest() {
    if [ $dest_remote -eq 1 ]; then
        run_remote "$dest_host" "$@"
    else
        "$@"
    fi
}

process_arguments "$@"
shift $((OPTIND - 1))

paths=()
for arg; do
    if [ "$arg" = "--" ]; then
        shift
        break
    fi
    paths+=("$arg")
    shift
done
if [[ ${#paths[@]} -ne 2 ]]; then
    show_help
    exit 1
fi
source=${paths[0]}
destination_root=${paths[1]}
if [[ "$destination_root" == *:* ]]; then
    dest_remote=1
    dest_host="${destination_root%%:*}"
    dest_path="${destination_root#*:}"
else
    dest_remote=0
    dest_host=
    dest_path="$destination_root"
fi

case "$config_file" in
/*) ;;
*) config_file=$source/$config_file ;;
esac

read_config_file() {
    local config_file="$1"
    shift
    local tempfile

    tempfile="$(mktemp "$tmpdir/config.XXXXXX")"

    rsync -a "$config_file" "$tempfile"
    cat "$tempfile" |
        { grep -v '^#' || true; } |
        { grep -Ev '^[ \t]*$' || true; } |
        while read -r line; do
            case "$line" in
            include\ *)
                include_file=${line#include }
                case "$include_file" in
                /*) ;;
                *)
                    include_file="$(dirname "$config_file")/$include_file"
                    ;;
                esac
                if ! [ -e "$include_file" ]; then
                    die "Error: include file $include_file from $config_file not found"
                fi
                read_config_file "$include_file"
                ;;
            *)
                printf '%s\n' "$line"
                ;;
            esac
        done
}

read_config_line () {
    local entry extra
    local argvar="$1"
    local extraargvar="$2"

    # shellcheck disable=SC2229
    IFS=$'\t' read -r entry extra || return $?

    # We handle quoted arguments, etc here, but leave any wildcards to the libsync script.
    # This also avoids any use of eval.
    IFS=$'\n' read -d '' -r -a "$argvar" < <(python3 -c 'import shlex, sys; [print(x) for x in shlex.split(sys.argv[1])]' "$entry") || :

    if [ -n "$extra" ]; then
        IFS=$'\n' read -d '' -r -a "$extraargvar" < <(python3 -c 'import shlex, sys; [print(x) for x in shlex.split(sys.argv[1])]' "$extra") || :
    fi
}

test_path() {
    local invert
    local check_path="$1"
    local dest_path="$2"

    case "$check_path" in
    '!'*)
        invert=1
        ;;
    *)
        invert=0
        ;;
    esac

    case "$check_path" in
    /*) ;;
    *)
        check_path="$dest_path/$check_path"
        ;;
    esac
    if [ $invert -eq 1 ]; then
        if run_dest test -e "$check_path"; then
            return 1
        fi
    else
        if ! run_dest test -e "$check_path"; then
            return 2
        fi
    fi </dev/null
    return 0
}

failed=0
src_args=()
extra_args=()

read_config_file "$config_file" >"$tmpdir/config"
while read_config_line src_args extra_args; do
    if [ $conditional_mode -eq 1 ]; then
        check_path="${src_args[0]}"
        src_args=("${src_args[@]:1}")

        if ! test_path "$check_path" "$dest_path"; then
            test_ret=$?
            if [ $test_ret -eq 1 ]; then
                msg_yellow "Skipping ${src_args[*]} because $check_path does not exist"
                continue
            elif [ $test_ret -eq 1 ]; then
                msg_yellow "Skipping ${src_args[*]} because $check_path exists"
                continue
            fi
        else
            msg_verbose "Syncing ${src_args[*]}, as path check is successful for $check_path"
        fi
    fi

    if ! run_libsync "${src_args[@]}" -- "${extra_args[@]}" "$@" </dev/null; then
        if should_die "Failed to sync ${src_args[*]}"; then
            exit 1
        else
           failed=$((failed + 1))
        fi
    fi
done <"$tmpdir/config"

if [[ $failed -ne 0 ]]; then
    if [[ -n "$continue_on_error" ]]; then
        suffix=
        if [[ $failed -gt 1 ]]; then
            suffix=s
        fi
        msg_red "Failed to sync $failed path$suffix"
    fi
    exit 1
fi
